"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dedent";
exports.ids = ["vendor-chunks/dedent"];
exports.modules = {

/***/ "(ssr)/./node_modules/dedent/dist/dedent.mjs":
/*!*********************************************!*\
  !*** ./node_modules/dedent/dist/dedent.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst dedent = createDedent({});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dedent);\nfunction createDedent(options) {\n  dedent.withOptions = newOptions => createDedent(_objectSpread(_objectSpread({}, options), newOptions));\n  return dedent;\n  function dedent(strings, ...values) {\n    const raw = typeof strings === \"string\" ? [strings] : strings.raw;\n    const {\n      alignValues = false,\n      escapeSpecialCharacters = Array.isArray(strings),\n      trimWhitespace = true\n    } = options;\n\n    // first, perform interpolation\n    let result = \"\";\n    for (let i = 0; i < raw.length; i++) {\n      let next = raw[i];\n      if (escapeSpecialCharacters) {\n        // handle escaped newlines, backticks, and interpolation characters\n        next = next.replace(/\\\\\\n[ \\t]*/g, \"\").replace(/\\\\`/g, \"`\").replace(/\\\\\\$/g, \"$\").replace(/\\\\\\{/g, \"{\");\n      }\n      result += next;\n      if (i < values.length) {\n        const value = alignValues ? alignValue(values[i], result) : values[i];\n\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        result += value;\n      }\n    }\n\n    // now strip indentation\n    const lines = result.split(\"\\n\");\n    let mindent = null;\n    for (const l of lines) {\n      const m = l.match(/^(\\s+)\\S+/);\n      if (m) {\n        const indent = m[1].length;\n        if (!mindent) {\n          // this is the first indented line\n          mindent = indent;\n        } else {\n          mindent = Math.min(mindent, indent);\n        }\n      }\n    }\n    if (mindent !== null) {\n      const m = mindent; // appease TypeScript\n      result = lines\n      // https://github.com/typescript-eslint/typescript-eslint/issues/7140\n      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n      .map(l => l[0] === \" \" || l[0] === \"\\t\" ? l.slice(m) : l).join(\"\\n\");\n    }\n\n    // dedent eats leading and trailing whitespace too\n    if (trimWhitespace) {\n      result = result.trim();\n    }\n\n    // handle escaped newlines at the end to ensure they don't get stripped too\n    if (escapeSpecialCharacters) {\n      result = result.replace(/\\\\n/g, \"\\n\");\n    }\n    return result;\n  }\n}\n\n/**\n * Adjusts the indentation of a multi-line interpolated value to match the current line.\n */\nfunction alignValue(value, precedingText) {\n  if (typeof value !== \"string\" || !value.includes(\"\\n\")) {\n    return value;\n  }\n  const currentLine = precedingText.slice(precedingText.lastIndexOf(\"\\n\") + 1);\n  const indentMatch = currentLine.match(/^(\\s+)/);\n  if (indentMatch) {\n    const indent = indentMatch[1];\n    return value.replace(/\\n/g, `\\n${indent}`);\n  }\n  return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGVkZW50L2Rpc3QvZGVkZW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDZEQUE2RCxpRUFBaUUsc0NBQXNDO0FBQ3ZVLGlDQUFpQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELDZEQUE2RCw0Q0FBNEMsb0tBQW9LLG1GQUFtRixLQUFLO0FBQzFlLDRDQUE0QywyQkFBMkIsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjtBQUMvTiwrQkFBK0IsdUNBQXVDO0FBQ3RFLHFDQUFxQywrREFBK0Qsc0NBQXNDLDBCQUEwQiwrQ0FBK0MseUNBQXlDLHVFQUF1RTtBQUNuVSw4QkFBOEI7QUFDOUIsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsTUFBTTtBQUM3RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N3YW5zLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2RlZGVudC9kaXN0L2RlZGVudC5tanM/MjgyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmNvbnN0IGRlZGVudCA9IGNyZWF0ZURlZGVudCh7fSk7XG5leHBvcnQgZGVmYXVsdCBkZWRlbnQ7XG5mdW5jdGlvbiBjcmVhdGVEZWRlbnQob3B0aW9ucykge1xuICBkZWRlbnQud2l0aE9wdGlvbnMgPSBuZXdPcHRpb25zID0+IGNyZWF0ZURlZGVudChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCBuZXdPcHRpb25zKSk7XG4gIHJldHVybiBkZWRlbnQ7XG4gIGZ1bmN0aW9uIGRlZGVudChzdHJpbmdzLCAuLi52YWx1ZXMpIHtcbiAgICBjb25zdCByYXcgPSB0eXBlb2Ygc3RyaW5ncyA9PT0gXCJzdHJpbmdcIiA/IFtzdHJpbmdzXSA6IHN0cmluZ3MucmF3O1xuICAgIGNvbnN0IHtcbiAgICAgIGFsaWduVmFsdWVzID0gZmFsc2UsXG4gICAgICBlc2NhcGVTcGVjaWFsQ2hhcmFjdGVycyA9IEFycmF5LmlzQXJyYXkoc3RyaW5ncyksXG4gICAgICB0cmltV2hpdGVzcGFjZSA9IHRydWVcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIC8vIGZpcnN0LCBwZXJmb3JtIGludGVycG9sYXRpb25cbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG5leHQgPSByYXdbaV07XG4gICAgICBpZiAoZXNjYXBlU3BlY2lhbENoYXJhY3RlcnMpIHtcbiAgICAgICAgLy8gaGFuZGxlIGVzY2FwZWQgbmV3bGluZXMsIGJhY2t0aWNrcywgYW5kIGludGVycG9sYXRpb24gY2hhcmFjdGVyc1xuICAgICAgICBuZXh0ID0gbmV4dC5yZXBsYWNlKC9cXFxcXFxuWyBcXHRdKi9nLCBcIlwiKS5yZXBsYWNlKC9cXFxcYC9nLCBcImBcIikucmVwbGFjZSgvXFxcXFxcJC9nLCBcIiRcIikucmVwbGFjZSgvXFxcXFxcey9nLCBcIntcIik7XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gbmV4dDtcbiAgICAgIGlmIChpIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFsaWduVmFsdWVzID8gYWxpZ25WYWx1ZSh2YWx1ZXNbaV0sIHJlc3VsdCkgOiB2YWx1ZXNbaV07XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzXG4gICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBub3cgc3RyaXAgaW5kZW50YXRpb25cbiAgICBjb25zdCBsaW5lcyA9IHJlc3VsdC5zcGxpdChcIlxcblwiKTtcbiAgICBsZXQgbWluZGVudCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBsIG9mIGxpbmVzKSB7XG4gICAgICBjb25zdCBtID0gbC5tYXRjaCgvXihcXHMrKVxcUysvKTtcbiAgICAgIGlmIChtKSB7XG4gICAgICAgIGNvbnN0IGluZGVudCA9IG1bMV0ubGVuZ3RoO1xuICAgICAgICBpZiAoIW1pbmRlbnQpIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBmaXJzdCBpbmRlbnRlZCBsaW5lXG4gICAgICAgICAgbWluZGVudCA9IGluZGVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaW5kZW50ID0gTWF0aC5taW4obWluZGVudCwgaW5kZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluZGVudCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbSA9IG1pbmRlbnQ7IC8vIGFwcGVhc2UgVHlwZVNjcmlwdFxuICAgICAgcmVzdWx0ID0gbGluZXNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90eXBlc2NyaXB0LWVzbGludC90eXBlc2NyaXB0LWVzbGludC9pc3N1ZXMvNzE0MFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItc3RyaW5nLXN0YXJ0cy1lbmRzLXdpdGhcbiAgICAgIC5tYXAobCA9PiBsWzBdID09PSBcIiBcIiB8fCBsWzBdID09PSBcIlxcdFwiID8gbC5zbGljZShtKSA6IGwpLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuXG4gICAgLy8gZGVkZW50IGVhdHMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSB0b29cbiAgICBpZiAodHJpbVdoaXRlc3BhY2UpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC50cmltKCk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGVzY2FwZWQgbmV3bGluZXMgYXQgdGhlIGVuZCB0byBlbnN1cmUgdGhleSBkb24ndCBnZXQgc3RyaXBwZWQgdG9vXG4gICAgaWYgKGVzY2FwZVNwZWNpYWxDaGFyYWN0ZXJzKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvXFxcXG4vZywgXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGp1c3RzIHRoZSBpbmRlbnRhdGlvbiBvZiBhIG11bHRpLWxpbmUgaW50ZXJwb2xhdGVkIHZhbHVlIHRvIG1hdGNoIHRoZSBjdXJyZW50IGxpbmUuXG4gKi9cbmZ1bmN0aW9uIGFsaWduVmFsdWUodmFsdWUsIHByZWNlZGluZ1RleHQpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY29uc3QgY3VycmVudExpbmUgPSBwcmVjZWRpbmdUZXh0LnNsaWNlKHByZWNlZGluZ1RleHQubGFzdEluZGV4T2YoXCJcXG5cIikgKyAxKTtcbiAgY29uc3QgaW5kZW50TWF0Y2ggPSBjdXJyZW50TGluZS5tYXRjaCgvXihcXHMrKS8pO1xuICBpZiAoaW5kZW50TWF0Y2gpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBpbmRlbnRNYXRjaFsxXTtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXFxuL2csIGBcXG4ke2luZGVudH1gKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dedent/dist/dedent.mjs\n");

/***/ })

};
;